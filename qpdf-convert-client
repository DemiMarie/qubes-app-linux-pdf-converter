#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# The Qubes OS Project, http://www.qubes-os.org
#
# Copyright (C) 2013 Joanna Rutkowska <joanna@invisiblethingslab.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from collections import namedtuple
import os
from PIL import Image
import subprocess
import sys
import tempfile

PROG_NAME = os.path.basename(sys.argv[0])
ARCHIVE_PATH = f"{os.path.expanduser('~')}/QubesUntrustedPDFs"

MAX_PAGES = 10000
MAX_IMG_WIDTH = 10000
MAX_IMG_HEIGHT = 10000
MAX_IMG_SIZE = MAX_IMG_WIDTH * MAX_IMG_HEIGHT * 3


###############################
#         Utilities
###############################

def check_range(val, upper):
    if (not 1 <= val <= upper) or (not 1 <= val <= upper):
            raise ValueError


###############################
#       Files & Images
###############################

def receive_page_count():
    # TODO: Can't the # of pages be modified by a malicious server?
    try:
        page_count = int(input())
        check_range(page_count, MAX_PAGES)
    except ValueError as err:
        print("Invalid number of pages returned... aborting!", file=sys.stderr)
        sys.exit(1)

    return page_count

def receive_img_measurements():
    return (int(val) for val in input().split(' ', 2))

def get_img_size(width, height):
    size = width * height * 3

    if size > MAX_IMG_SIZE:
        print("Calculated image size is too large... aborting!",
               file=sys.stderr)
        sys.exit(1)

    return size

def get_img_dimensions():
    depth = 8

    try:
        width, height = receive_img_measurements()
        check_range(width, MAX_IMG_WIDTH)
        check_range(height, MAX_IMG_HEIGHT)
    except ValueError as err:
        print("Invalid image geometry returned... aborting!", file=sys.stderr)
        sys.exit(1)

    size = get_img_size(width, height)

    Dimensions = namedtuple('Dimensions', 'width height depth size')
    return Dimensions(width=width, height=height, size=size, depth=depth)

def get_tmp_rgb(rgb_path, size):
    # XXX: For some reason, this leaves us missing alot of bytes
    # rcvd_bytes = input().encode('utf-8', 'surrogateescape')
    # rcvd_bytes = rcvd_bytes[:dimensions.size]

    # XXX: Example of using PIL for performant PNG -> JPG. Maybe use this?
    # png = Image.open(object.logo.path)
    # png.load() # required for png.split()
    # background = Image.new("RGB", png.size, (255, 255, 255))
    # background.paste(png, mask=png.split()[3]) # 3 is the alpha channel
    # background.save('foo.jpg', 'JPEG', quality=80)

    with open(rgb_path, 'wb') as rgb_f:
        # FIXME: Why can't we get this in pure Python????? This isn't
        # Windows-compatible
        subprocess.run(['head', '-c', f'{size}'], stdout=rgb_f, check=True)

        if os.path.getsize(rgb_f.name) != size:
            print('Invalid number of bytes in RGB file... aborting!',
                  file=sys.stderr)
            os.remove(rgb_path)
            sys.exit(1)

def rgb_to_png(rgb_path, png_path, dimensions, page):
        try:
            subprocess.run(['convert',
                           '-size' , f'{dimensions.width}x{dimensions.height}',
                           '-depth', f'{dimensions.depth}',
                           f'rgb:{rgb_path}', f'png:{png_path}'], check=True)
        except subprocess.CalledProcessError as err:
            print(f'Page {page} conversion failed (RGB->PNG): {err}',
                  file=sys.stderr)
            sys.exit(1)
        else:
            os.remove(rgb_path)

def convert_received_rgb_file(dimensions, page):
    # TODO: Does the number of X's matter?
    with tempfile.NamedTemporaryFile(prefix='qpdf-conversion-') as rcvd_f:
        rgb_path = f'{rcvd_f.name}-{page}.rgb'
        png_path = f'{rcvd_f.name}-{page}.png'
        get_tmp_rgb(rgb_path, dimensions.size)
        rgb_to_png(rgb_path, png_path, dimensions, page)

    return png_path

def process_pdf(untrusted_pdf, page_count):
    page = 1
    images = []
    trusted_pdf = f'{os.path.splitext(untrusted_pdf)[0]}.trusted.pdf'

    print("Waiting for converted sample...", file=sys.stderr)
    while page <= page_count:
        dimensions = get_img_dimensions()

        # TODO: There's some weird verbose condition here in the og script
        print(f'Receiving page {page}/{page_count}...', end='\r',
              file=sys.stderr)
        png_path = convert_received_rgb_file(dimensions, page)
        images.append(Image.open(png_path))

        page += 1
    else:
        print('', file=sys.stderr)

    # TODO: Maybe it'd be better to save->delete png over and over again to
    # avoid storing all PNGs in memory
    images[0].save(trusted_pdf, 'PDF', resolution=100.0, save_all=True,
                   append_images=images[1:])

    for img in images:
        img.close()
        os.remove(img.filename)

    print(f'Converted PDF saved as: {trusted_pdf}', file=sys.stderr)

def archive_pdf(untrusted_pdf):
    archived_pdf = f'{ARCHIVE_PATH}/{os.path.basename(untrusted_pdf)}'
    os.rename(untrusted_pdf, archived_pdf)
    print(f'Original PDF saved as: {archived_pdf}', file=sys.stderr)

def mkdir_archive():
    if not os.path.exists(ARCHIVE_PATH):
        os.mkdir(ARCHIVE_PATH)

###############################
#       qrexec-related
###############################

def send_pdf_file(untrusted_pdf):
    print('Sending file to a Disposable VM...', file=sys.stderr)
    with open(untrusted_pdf, 'rb') as f:
        sys.stdout.buffer.write(f.read())
    os.close(sys.stdout.fileno())

def process_pdfs(untrusted_pdfs):
    # TODO: Remove [0] when support for multiple PDFs is available
    # for untrusted_pdf in untrusted_pdfs:
    send_pdf_file(untrusted_pdfs[0])
    page_count = receive_page_count()
    process_pdf(untrusted_pdfs[0], page_count)
    archive_pdf(untrusted_pdfs[0])

def main():
    untrusted_pdfs = sys.argv[1:]
    mkdir_archive()
    process_pdfs(untrusted_pdfs)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt as e:
        sys.exit(0)
