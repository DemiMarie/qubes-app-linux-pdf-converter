#!/bin/bash
#
# The Qubes OS Project, http://www.qubes-os.org
#
# Copyright (C) 2013  Joanna Rutkowska <joanna@invisiblethingslab.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Requires: 
# - ImageMagick (convert)

INPUT_FILE=$1
RCVD_FILE=$(mktemp --tmpdir qpdf-conversion-XXXXXXXX)
CONVERTED_FILE=$(basename $1 .pdf).converted.pdf


MAX_PAGES=10000
MAX_IMG_WIDTH=10000
MAX_IMG_HEIGHT=10000
IMG_DEPTH=8
MAX_IMG_SIZE=$(($MAX_IMG_WIDTH*$MAX_IMG_HEIGHT*3))

VERBOSE=1


# Send the input (untrusted) file to the server...
[ $VERBOSE -ge 1 ] && echo "-> Sending file to remote VM..." > /dev/stderr
cat $INPUT_FILE
exec >&-

# ... and get the recvd *simple* representation:

# Note: the server might be comrpomised at this point so, it can very well send
# us something else than the simple representation.  Thus we explicitly specify
# input format to ImageMagick's convert via "rgb:" prefix, forcing it to
# interpret whatever stream of bytes it gets on input as a simple RGB array. We
# hope that when using this RGB format explcitly (which is the simplest format
# for bitmaps in the known universe), there is no space for offending bug in
# image parsing...

# First, get the no of pages:
read NO_PAGES
if [[ ! $NO_PAGES =~ ^[0-9]+$ ]] || [[ $NO_PAGES -le 0 ]] || [[ $NO_PAGES -gt $MAX_PAGES ]] ; then
    echo "The remote party return invalid no of pages, aborting!" > /dev/stderr
    exit 1
fi

[ $VERBOSE -ge 1 ] && echo "-> Waiting for converted samples..." > /dev/stderr

PAGE=1
while [ $PAGE -le $NO_PAGES ]; do
    read IMG_WIDTH IMG_HEIGHT
    if [ $VERBOSE -eq 1 ]; then
        echo -n "-> Receving page $PAGE out of $NO_PAGES..." > /dev/stderr
        printf "\r" > /dev/stderr
    elif [ $VERBOSE -gt 1 ]; then    
        echo "-> Receving page $PAGE out of $NO_PAGES..." > /dev/stderr
    fi
    if [[ ! "$IMG_WIDTH" =~ ^[0-9]+$ ]] || [ $IMG_WIDTH -le 0 ] || [ $IMG_WIDTH -gt $MAX_IMG_WIDTH ] || \
       [[ ! "$IMG_HEIGHT" =~ ^[0-9]+$ ]] || [ $IMG_HEIGHT -le 0 ] || [ $IMG_HEIGHT -gt $MAX_IMG_HEIGHT ]; then
        echo "The remote party return invalid image geometry info, aborting!" > /dev/stderr
        exit 2
    fi
    [ $VERBOSE -ge 2 ] && echo "--> page geometry: $IMG_WIDTH x $IMG_HEIGHT x $IMG_DEPTH" > /dev/stderr
    IMG_SIZE=$((IMG_WIDTH*IMG_HEIGHT*3))
    if [ $IMG_SIZE -le 0 ] || [ $IMG_SIZE -gt $MAX_IMG_SIZE ]; then
        echo "Calculated image size is invalid, aborting!" > /dev/stderr
    fi
    # save the simplified RGB image into a temp file:
    RGB_FILE=$RCVD_FILE-$PAGE.rgb
    head -c $IMG_SIZE > $RGB_FILE
    [ $VERBOSE -ge 2 ] && echo "--> saved to file: $RGB_FILE" > /dev/stderr
    PAGE=$(($PAGE+1))
done

if [ $VERBOSE -eq 1 ]; then
    echo > /dev/stderr
fi
 
# Now convert the simple representation back to a PDF...
[ $VERBOSE -ge 1 ] && echo "-> Saving converted PDF: $CONVERTED_FILE..." > /dev/stderr
convert -size ${IMG_WIDTH}x${IMG_HEIGHT} -depth ${IMG_DEPTH} rgb:$RCVD_FILE-*.rgb $CONVERTED_FILE

# Cleanup
rm -f $RCVD_FILE*
